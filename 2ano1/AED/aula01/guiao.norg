@document.meta
title: Aula 01
description: Introdu√ß√£o a C
author: Jo√£o Capucho
@end

* Introdu√ß√£o

  A linguagem de programa√ß√£o C √© uma linguagem de baixo n√≠vel, isto significa
  que ao contr√°rio de linguagens como Python e Java onde muito dos detalhes nos
  eram escondidos, em C vamos os ter presentes e vamos ter de lidar com eles.

  O detalhe que vai ter mais presen√ßa √© o da gest√£o de mem√≥ria, enquanto outras
  linguagens costumam optar pela gest√£o autom√°tica da mem√≥ria, recorrendo a
  Garbage Collectors e outros mecanismos, em C a gest√£o √© feita de forma manual
  sendo o programador respons√°vel por decidir onde, quando e quanto alocar e
  libertar em termos de mem√≥ria.

  Isto faz com que seja poss√≠vel construir programas altamente eficientes,
  visto que existe um controlo maior sobre todas as partes do programa. No
  entanto, tamb√©m √© mais f√°cil cometer erros e n√£o existem guias nem mecanismos
  de seguran√ßa, o que significa que os erros s√£o mais dif√≠ceis de detetar e
  carregam com eles perigos maiores (grande parte dos problemas de seguran√ßa
  partem de problemas na gest√£o de mem√≥ria).

  Al√©m disto C √© uma linguagem antiga tendo sido criada nos anos 70, isto faz
  com que v√°rias partes da linguagem apresentem bagagem hist√≥rica e escolhas
  que na altura faziam sentido, mas atualmente j√° n√£o fazem.

** Ferramentas

   C √© uma linguagem compilada como tal √© preciso instalar um compilador para
   compilar o c√≥digo num execut√°vel antes de o poder executar.

   O compilador recomendado √© o `gcc`, este pode ser facilmente instalado em
   linux atrav√©s do package manager da distro. Em Windows √© recomendado
   utilizar WSL (√© poss√≠vel instalar gcc em Windows "diretamente", mas a
   experi√™ncia √© bastante pior e algumas livrarias de suporte podem n√£o
   funcionar).

   O `gcc` pode ser chamado diretamente com o nome do ficheiro que cont√™m o
   c√≥digo C:

   @code sh
   gcc test.c
   @end

   Isto ir√° produzir um execut√°vel com o nome `a.out`, isto √© devido a raz√µes
   hist√≥ricas, apesar de atualmente n√£o ser comum os execut√°veis terem
   extens√µes em sistemas linux.

   Podemos utilizar a op√ß√£o `-o` para instruir ao `gcc` para produzir um
   execut√°vel com o nome que quisermos:

   @code sh
   gcc test.c -o main
   @end

   Existem mais umas op√ß√µes que ser√£o √∫teis, entre estas est√£o algumas op√ß√µes
   para ativar mensagens de aviso, devido √† maneira como a linguagem C √©
   desenvolvida a introdu√ß√£o de mensagens de aviso (n√£o de erro) √© considerada
   uma mudan√ßa que quebra a compatibilidade com vers√µes anteriores, cabendo
   ent√£o ao utilizador ativ√°-las.

   No entanto, estas op√ß√µes s√£o bastantes √∫teis, apanhando muitos erros comuns,
   e poupando muitas dores de cabe√ßa, o que √© crucial numa linguagem como C que
   est√° coberta de perigos.

   Estas op√ß√µes s√£o:
   - `-Wall` ativa alguns avisos extra
   - `-Wextra` ativa ainda mais avisos extra do que `-Wall`
   - `-Wpedantic` ativa ainda mais avisos extra do que `-Wextra`, estes
     avisos s√£o menos necess√°rios, mas mesmo assim podem mostrar problemas
     maiores com o programa em geral.
   - `-Werror` esta op√ß√£o transforma todas as mensagens de aviso em mensagens
     de erro, pois as mensagens de aviso maior parte das vezes deviam ser erros.

   Eu juro que n√£o √© par√≥dia e todas estas op√ß√µes existem e fazem coisas
   diferentes üò≠.

   Finalmente a √∫ltima op√ß√£o que nos poder√° ser √∫til √© a `-g`, esta op√ß√£o
   inclui informa√ß√µes de debugging no programa gerado permitindo a utiliza√ß√£o
   de outras ferramentas como debuggers para ajudar na resolu√ß√£o de problemas
   (que inevitavelmente apareceram).

   Com isto tudo ficamos com o seguinte comando para compilar c√≥digo:

   @code sh
   gcc -g -Wextra -Wall -Werror -Wpedantic -o main test.c
   @end

   Escrever isto tudo de cada vez que for para compilar torna-se excessivo, por
   isso vamos criar um script para resolver isso `compile`:

   @code bash
   #!/usr/bin/env bash
   gcc -g -Wextra -Wall -Werror -Wpedantic -o main "$@"
   @end

   Este script invoca o `gcc` com as op√ß√µes discutidas em cima e todos os argumentos
   que passarmos ao nosso script. Basta agora tornamos o script execut√°vel:

   @code sh
   chmod +x compile
   @end

   E agora para compilar o c√≥digo basta utilizar o script:

   @code sh
   ./compile test.c
   @end

   E se quisermos compilar e executar o programa podemos utilizar a seguinte
   linha:

   @code sh
   ./compile test.c && ./main
   @end

   E compilar com op√ß√µes extras:

   @code sh
   ./compile -std=c11 test.c
   @end

* Exerc√≠cio 1

  >  Usando um editor √† sua escolha, crie um ficheiro com o programa seguinte (simplest_1.c).

  @code c
  int main ( void )
  {
     // O programa mais simples em C
  }
  @end

  > Nota algum pormenor estranho neste programa?

  A declara√ß√£o de fun√ß√µes em C √© muito semelhante √† declara√ß√£o de m√©todos em
  Java, por isso a presen√ßa do void no lugar dos argumentos da fun√ß√£o pode
  parecer estranho.

  Tal como em Java, em C o tipo `void` representa o tipo vazio e √© comum como o
  tipo de fun√ß√µes que n√£o retornam nada, no entanto, em C quando queremos
  declarar fun√ß√µes sem argumentos tamb√©m temos que utilizar `void`, pois as
  duas fun√ß√µes seguintes n√£o s√£o iguais:

  @code c
  void test(void) {}
  void test_no_void() {}
  @end

  A primeira como j√° discutimos n√£o aceita argumentos, no entanto, a segunda
  aceita qualquer n√∫mero de argumentos.

  @code c
  void test(void) {}
  void test_no_void() {}

  int main() {
     test();          // Funciona
     test(1);         // Erro
     test_no_void();  // Funciona
     test_no_void(1); // Funciona?
  }
  @end

  Isto √© mais uma decis√£o hist√≥rica e algumas ferramentas avisam contra o seu
  uso, sugerindo o uso da forma explicita de `...` como argumento. No nosso
  caso vamos precisar de ter o cuidado de meter  `void` nas fun√ß√µes onde n√£o
  s√£o esperados argumentos.

  > Use o seu compilador da linguagem C para compilar o ficheiro; analise
    eventuais mensagens do compilador. Execute o programa de aplica√ß√£o
    resultante.

  @code sh
  ./compile simplest_1.c && ./main
  @end

  Como √© expect√°vel o compilador n√£o retorna nenhuma mensagem e a execu√ß√£o do
  programa n√£o faz nada.

  > Experimente compilar o ficheiro usando diferentes normas da linguagem:
    `-std=c17`, `-std=c11`, `-std=c99` ou `-std=c90`. Analise eventuais
    mensagens do compilador.

  A linguagem C √© desenvolvida pelo comit√© ISO C, este define uma especifica√ß√£o
  ISO C, que define como a linguagem deve funcionar e livrarias comuns a todas
  as implementa√ß√µes.

  Esta especifica√ß√£o est√° em constante constru√ß√£o sendo publicada
  irregularmente na forma de standards a op√ß√£o `-std` controla a vers√£o do
  standard que queremos utilizar, `c17` √© o standard de 2017 enquanto que `c99`
  √© o standard de 1999.

  Se compilarmos o c√≥digo dado com `c17`, `c11` ou `c99` este compila e
  funciona normalmente.

  No entanto, se usarmos `c90` o compilador retorna-nos v√°rios erros:

  @code
  $ gcc -Wall -std=c90 simplest_1.c
  simplest_1.c: In function ‚Äòmain‚Äô:
  simplest_1.c:3:3: error: C++ style comments are not allowed in ISO C90
       3 |   // O programa mais simples em C
         |   ^
  simplest_1.c:3:3: note: (this will be reported only once per input file)
  simplest_1.c:4:1: warning: control reaches end of non-void function [-Wreturn-type]
       4 | }
         | ^
  @end

  O primeiro erro √© estranho, o compilador fala de coment√°rios a C++, mas de
  facto at√© 1999, C s√≥ suportava coment√°rios do estilo `/* comment */`, apenas
  quando C++ popularizou os coment√°rios de linha `// comment` √© que estes foram
  implementados em C.

  O segundo aviso faz sentido sendo estranho que as vers√µes mais recentes n√£o o
  emitam, o que n√£o √© bem verdade porque se definirmos outra fun√ß√£o que n√£o
  `main` que o tipo de retorno n√£o seja `void` e n√£o retornemos nada o mesmo
  aviso ir√° aparecer.

  A diferen√ßa √© que em `c90` todas as fun√ß√µes que deviam retornar, mas n√£o
  retornam fazem com que o uso do valor retornado (que n√£o foi) seja /Undefined Behavior/
  (UB), o que significa que tudo pode acontecer desde crashar o programa at√©
  corromper mem√≥ria.

  @code c
  int test() {} // Doesn't return

  int main() {
     int a = test(); // UB
     // O programa pode ou n√£o chegar a este ponto...
     // Podendo (ou n√£o) ter corrompido a mem√≥ria toda...
     // Podendo (ou n√£o) tido causado graves problemas de seguran√ßa...
     return 0;
  }
  @end

  Por isso √© que o compilador avisa-nos deste problema (o facto de n√£o ser um
  erro ultrapassa-me), porque h√° uma bomba rel√≥gio no nosso c√≥digo pronta a
  explodir.

  Na vers√£o `c99` o comit√© decidiu cortar uma exce√ß√£o para a fun√ß√£o `main`,
  esta agora se retornar algo que n√£o seja um `int` (ou se s√≥ n√£o retornar de
  todo) n√£o existe UB, simplesmente o status code do programa √© definido pela
  implementa√ß√£o (compilador/sistema operativo).

  Sendo por isto que as vers√µes mais recentes n√£o mostram o aviso.

  > Modifique o ficheiro de acordo com o exemplo seguinte.

  @code c
  #include<stdio.h>

  int main ( void )
  {
     printf ( "%ld\n", __STDC_VERSION__ );
     return 0;
  }
  @end

  > Compile e execute o programa usando diferentes normas da linguagem. Analise
    eventuais mensagens do compilador e o resultado do programa.

  @code
  $ ./compile -std=c90 simplest_1.c && ./main
  simplest_1.c: In function ‚Äòmain‚Äô:
  simplest_1.c:4:19: error: ‚Äò__STDC_VERSION__‚Äô undeclared (first use in this function)
       4 |   printf("%ld\n", __STDC_VERSION__);
         |                   ^~~~~~~~~~~~~~~~
  simplest_1.c:4:19: note: each undeclared identifier is reported only once for each function it appears in
  @end

  Esta diretiva n√£o foi introduzida at√© a vers√£o `c99`.

  @code
  $ ./compile -std=c99 simplest_1.c && ./main
  199901
  @end

  @code
  $ ./compile -std=c11 simplest_1.c && ./main
  201112
  @end

  @code
  $ ./compile -std=c17 simplest_1.c && ./main
  201710
  @end

  > Qual √© o tipo da constante __STDC_VERSION__?

  O tipo da constante √© `long int`, como podemos deduzir do especificador `%ld`
  que utilizamos.

  > Qual √© o significado do seu valor?

  O valor da constante √© `yyyymm` onde `y` √© o ano e `m` o m√™s quando foi
  ratificada a vers√£o do standard que o compilador utiliza, isto pode ser
  usado, por exemplo, por livrarias para condicionalmente utilizarem fun√ß√µes
  novas e, em simult√¢neo, suportar vers√µes antigas atrav√©s de outros m√©todos.

  > Qual √© a norma que o seu compilador usa por omiss√£o?

  `201710` que √© a vers√£o mais recente suportada, existe uma op√ß√£o `-std=c2x`,
  mas o suporte para essa vers√£o ainda n√£o √© total.

* Exerc√≠cio 2

  > Crie um ficheiro com o programa seguinte (hello_world.c). Compile e execute o programa.

  @code c
  #include<stdio.h>

  int main ( void )
  {
     puts ( "Hello World!" );
     return 0;
  }
  @end

  @code
  $ ./compile hello_world.c && ./main
  Hello World!
  @end

  > Experimente usar as fun√ß√µes printf() e fputs(). H√° diferen√ßas no resultado do programa?

  @code c
  #include <stdio.h>

  int main(void) {
     puts("Hello World!");          // Prints to stdout with newline
     printf("Hello World!");        // Prints to stdout no newline
     fputs("Hello World!", stdout); // Prints to a File no newline
     return 0;
  }
  @end

  A fun√ß√£o `puts` como j√° vimos imprime a string para o stdout, com uma linha
  nova no final. A fun√ß√£o `fputs` √© uma vers√£o mais gen√©rica de `puts` que
  permite escolher qualquer ficheiro para escrever (incluindo stdout) e n√£o
  adiciona a linha nova.

  A fun√ß√£o `printf` imprime para o stdout e sem a linha nova, mas tal como a
  fun√ß√£o `printf` em Java, a primeira string √© uma string de formata√ß√£o podendo
  utilizar-se sequ√™ncias especiais para formatar n√∫meros e outras strings.

* Exerc√≠cio 3

  > Crie um novo programa (hello_X.c) que pe√ßa o nome pr√≥prio e o apelido do
    utilizador e escreva, por exemplo, ‚ÄúHello Joaquim Madeira!‚Äù.
  > Experimente usar as fun√ß√µes gets(), fgets() e scanf(). Analise eventuais
    mensagens do compilador.

** `gets()`

   Vamos come√ßar por tentar `gets()`, a p√°gina do manual tinha avisos grandes a
   dizer para n√£o a usar... Vamos ignor√°-los por agora. A fun√ß√£o √© definida
   como:

   @code c
   char *gets(char *s);
   @end

   Esta fun√ß√£o l√™ do stdin at√© uma linha nova ou EOF (/End Of File/), substituindo
   estes por um byte nulo (`\0`). Al√©m disso, a fun√ß√£o retorna `NULL` se ocorrer
   um erro, vamos ter isso em aten√ß√£o.

   @code c
   #include <stdio.h>

   int main(void) {
      char name[5];

      // So heavily deprecated the stdio.h header doesn't include a definition by
      // default, unless we compile with `-std=c99` which means we are using the
      // ISO C version from 1999.
      //
      // Really DON'T USE THIS, it's so broken beyond repair even the linker
      // throws warning messages.
      if (gets(name) == NULL)
        return 1;

      printf("Hello %s\n", name);
      return 0;
   }
   @end

   Ignoremos os coment√°rios de aviso que meti para aquelas pessoas que copiam
   sem ler tudo, n√≥s come√ßamos por alocar um array/string de 5 bytes `name`,
   destes s√≥ 4 ser√£o carateres √∫teis porque em C as strings n√£o sabem o seu
   tamanho tendo inv√©s disso um byte nulo (`\0`) no seu final que significa o
   fim da string.

   A seguir chamamos `gets` que ir√° ler para `name` e verificamos se o seu
   resultado √© `NULL` sinalizando um erro que retornamos no status code do nosso
  programa.

   Finalmente formatamos `name` e imprimimos para o stdout com `printf` e
   o programa termina, vamos experimentar compilar.

   @code
   $ ./compile code/ex03-gets.c
   code/ex03-gets.c: In function ‚Äòmain‚Äô:
   code/ex03-gets.c:12:7: error: implicit declaration of function ‚Äògets‚Äô; did you mean ‚Äòfgets‚Äô? [-Werror=implicit-function-declaration]
      12 |   if (gets(name) == NULL) {
         |       ^~~~
         |       fgets
   code/ex03-gets.c:12:18: error: comparison between pointer and integer [-Werror]
      12 |   if (gets(name) == NULL) {
         |                  ^~
   cc1: all warnings being treated as errors
   @end

  Ok, ao que parece `gets` foi removido em `c11`, vamos tentar compilar com `c99`:

   @code
   $ ./compile -std=c99 code/ex03-gets.c
   code/ex03-gets.c: In function ‚Äòmain‚Äô:
   code/ex03-gets.c:12:3: error: ‚Äògets‚Äô is deprecated [-Werror=deprecated-declarations]
      12 |   if (gets(name) == NULL) {
         |   ^~
   In file included from /nix/store/p1wjbmik8bzpzcm2ck4yfxr6fnnc76mn-glibc-2.37-8-dev/include/stdio.h:906,
                    from code/ex03-gets.c:1:
   /nix/store/p1wjbmik8bzpzcm2ck4yfxr6fnnc76mn-glibc-2.37-8-dev/include/bits/stdio2.h:190:1: note: declared here
     190 | gets (char *__str)
         | ^~~~
   cc1: all warnings being treated as errors
   @end

   Hmm, vamos s√≥ ignorar erros por agora (*bad decision*):

   @code
   $ gcc -std=c99 code/ex03-gets.c
   code/ex03-gets.c: In function ‚Äòmain‚Äô:
   code/ex03-gets.c:12:3: warning: ‚Äògets‚Äô is deprecated [-Wdeprecated-declarations]
      12 |   if (gets(name) == NULL) {
         |   ^~
   In file included from /nix/store/p1wjbmik8bzpzcm2ck4yfxr6fnnc76mn-glibc-2.37-8-dev/include/stdio.h:906,
                    from code/ex03-gets.c:1:
   /nix/store/p1wjbmik8bzpzcm2ck4yfxr6fnnc76mn-glibc-2.37-8-dev/include/bits/stdio2.h:190:1: note: declared here
     190 | gets (char *__str)
         | ^~~~
   /nix/store/8zxgqm6d879hskwh5g1l4crysl01kdv0-binutils-2.40/bin/ld: /tmp/ccN8TsPq.o: in function `main':
   ex03-gets.c:(.text.startup+0x23): warning: the `gets' function is dangerous and should not be used.
   @end

   Finalmente o c√≥digo compilou, a mensagem de perigo n√£o √© bom sinal, mas vamos
   continuar.

   @code
   $ ./main
   cap <-- Inserido pelo utilizador
   Hello cap
   @end

   Estranho o programa funcionou apesar de tantos avisos para n√£o usar a fun√ß√£o,
   por que raz√£o ser√° que n√£o a dev√≠amos usar? Bem vamos ignorar esse pensamento
   por um segundo e vamos tentar outro nome.

   @code
   $ ./main
   antonio <-- Inserido pelo utilizador
   *** buffer overflow detected ***: terminated
   './main' terminated by signal SIGABRT (Abort)
   @end

   O programa crashou, isto n√£o √© bom sinal, mas por qu√™? Se voltarmos a olhar
   para o c√≥digo notamos que n√≥s apenas temos 5 bytes para o nome, mas
   `antonio` s√£o 7 bytes (8 com o byte nulo). Isto causa com que o `gets` tente
   escrever para al√©m da mem√≥ria alocada, neste caso isto √© apanhado por um
   pouco de c√≥digo extra que o compilador adicionou ao nosso programa para
   verificar esta situa√ß√£o. 

   No entanto, este c√≥digo √© algo extra que o compilador adicionou desta vez e
   conseguiu detetar esta situa√ß√£o, nada garante que ele esteja sempre presente
   (√© uma extens√£o que n√£o est√° presente no standard) e pode haver situa√ß√µes
   mais complexas que ele n√£o consegue detetar (como quando utilizando mem√≥ria
   alocada dinamicamente).

   Vamos ent√£o consertar este problema no nosso c√≥digo... √â *imposs√≠vel*! A
   fun√ß√£o `gets` n√£o disponibiliza nenhum tipo de mecanismo para limitar a
   quantidade lida, o que impossibilita consertar este c√≥digo √© por esta raz√£o
   que a fun√ß√£o foi deprecada e ultimamente removida. √â por esta raz√£o que
   todas as fontes dizem que √© perigosa e para n√£o utiliz√°-la. √â por esta raz√£o
   que o compilador injeta c√≥digo no nosso programa para prevenir esta
   cat√°strofe.

   *N√ÉO UTILIZEM ESTA FUN√á√ÉO*

** `fgets()`

   Ok, `gets` foi uma decis√£o terr√≠vel, mas o pr√≥ximo na lista √© `fgets`, o
   nome parecido pode nos levar a pensar que teremos o mesmo problema, no
   entanto, a fun√ß√£o `fgets` n√£o tem nenhum aviso nem est√° deprecada.

   Isto faz sentido se olharmos para a defini√ß√£o de `fgets`:

   @code c
   char *fgets(char *s, int size, FILE *stream);
   @end

   Tal como `gets` passamos um ponteiro para onde queremos guardar a string
   inserida, mas tamb√©m passamos o tamanho da mem√≥ria alocada para onde o
   ponteiro aponta. Isto permite-nos limitar a mem√≥ria escrita. Al√©m disto
   passamos tamb√©m o ficheiro de onde queremos ler.

   Tal como `gets`, esta fun√ß√£o l√™ at√© a linha nova ou EOF e retorna `NULL` em
   caso de erro, , *mas* ao contr√°rio de `gets` a linha nova n√£o √© substitu√≠da
   pelo byte nulo. Vamos ent√£o escrever um programa que utilize `fgets`:

   @code c
   #include <stdio.h>

   int main(void) {
      char name[5];

      if (fgets(name, 5, stdin) == NULL)
         return 1;

      printf("Hello %s\n", name);
      return 0;
   }
   @end

   Este programa √© id√™ntico √† vers√£o com `gets` com a exce√ß√£o que especificamos
   o tamanho da mem√≥ria alocada e o ficheiro de onde queremos ler, neste caso
   `stdin` que √© onde o utilizador ir√° escrever.

   @code
   $ ./compile code/ex03-fgets.c && ./main
   cap <-- Inserido pelo utilizador
   Hello cap
       <-- Linha nova que n√£o foi removida
   @end

   Como podemos ver a linha nova n√£o foi removida, se quisermos emular o mesmo
   resultado do programa com `gets`, vamos ter de percorrer a string e remover
   a linha nova:

   @code c
   #include <stdio.h>

   int main(void) {
      char name[5];

      if (fgets(name, 5, stdin) == NULL)
         return 1;

      // Vamos iterar pela string para remover o carater de
      // linha nova.
      for (int i = 0; i < 5; i++) {
         // Temos que garantir que n√£o processamos dados ap√≥s
         // o byte nulo, pois estes n√£o foram inicializados
         // sendo UB ler esses bytes.
         if (name[i] == '\0')
            break;

         // Substituimos a linha nova pelo byte nulo para terminar
         // a string e terminamos de processar a string.
         if (name[i] == '\n') {
            name[i] = '\0';
            break;
         }
      }

      printf("Hello %s\n", name);
      return 0;
   }
   @end

   Se corrermos este programa vamos obter o resultado pretendido:

   @code
   $ ./compile code/ex03-fgets-v2.c && ./main
   cap
   Hello cap
   @end

   No entanto, o programa agora t√™m 3 s√≠tios diferentes onde especificamos o
   tamanho do array, isto pode causar problemas mais tardes se mudarmos o
   tamanho do array e esquecermo-nos de mudar o tamanho em todos os s√≠tios.

   Para mitigar este problema podemos usar uma vari√°vel (ou at√© uma constante)
   para guardar o tamanho do array, mas como temos um array de tamanho fixo
   podemos utilizar outra ferramenta, o operador `sizeof` que diz o tamanho de
   bytes de uma vari√°vel.

   @code c
   #include <stddef.h>
   #include <stdio.h>

   int main(void) {
      char name[5];

      if (fgets(name, sizeof(name), stdin) == NULL)
         return 1;

      for (size_t i = 0; i < sizeof(name); i++) {
         if (name[i] == '\0')
            break;

         if (name[i] == '\n') {
            name[i] = '\0';
            break;
         }
      }

      printf("Hello %s\n", name);
      return 0;
   }
   @end

   @code
   $ ./compile code/ex03-fgets-v3.c && ./main
   cap
   Hello cap
   @end

   Basta agora ver se resolvemos o problema de escrever para al√©m da mem√≥ria:

   @code
   $ ./compile code/ex03-fgets-v3.c && ./main
   antonio
   Hello anto
   @end

   E est√° resolvido, o input do utilizador √© truncado de maneira a caber na
   mem√≥ria alocada, deste modo prevenindo escrita para fora da mem√≥ria.

** `scanf`

   J√° vimos que `fgets` funciona como queremos, basta ent√£o vermos a fun√ß√£o
   `scanf`, esta √© a vers√£o de leitura de `printf`, permitindo pegar numa linha
   formatada e extrair certas partes.

   @code c
   int scanf(const char *format, ...);
   @end

   Pela defini√ß√£o parece que vamos ter o mesmo problema que tivemos com a
   fun√ß√£o `gets`, no entanto, como veremos depois isto n√£o ir√° acontecer.

   A fun√ß√£o `scanf` vai ent√£o processar o input do utilizador segundo a string
   de formata√ß√£o, extraindo os valores especificados, o valor de retorno √© o
   n√∫mero de items formatados, o que implicara verificarmos este valor com o
   n√∫mero total de items a formatar.

   Vamos ent√£o rescrever o nosso programa com `scanf`:

   @code c
   #include <stdio.h>

   int main(void) {
      char name[5];

      if (scanf("%s", name) != 1)
         return 1;

      printf("Hello %s\n", name);
      return 0;
   }
   @end

   O especificador `%s` formata uma sequ√™ncia de caracteres que n√£o sejam de
   "espa√ßo".

   @code
   ./compile code/ex03-scanf-v1.c && ./main
   ana
   Hello ana
   @end

   O compilador n√£o se queixa como quando utilizamos `gets`, quer isto dizer
   que `scanf` √© seguro? Vamos tentar com uma string maior que o nosso array.

   @code
   ./compile code/ex03-scanf-v1.c && ./main
   antonio
   Hello antonio
   *** stack smashing detected ***: terminated
   './main' terminated by signal SIGABRT (Abort)
   @end

   N√£o, o programa escreveu para al√©m da mem√≥ria, o que mais uma vez foi
   apanhado por uma prote√ß√£o injetada pelo nosso compilador (estes erros s√£o
   bastantes comuns em C por isso os compiladores injetam v√°rias prote√ß√µes para
   os impedir, mas estas nem sempre est√£o presentes ou funcionam,
   principalmente quando trabalharmos com mem√≥ria din√¢mica).

   Como vamos ent√£o resolver este problema se n√£o h√° maneira de especificar o
   tamanho do array na fun√ß√£o? Na verdade, existe uma maneira especificar, mas
   em vez de ser como um argumento da fun√ß√£o, especificamos diretamente no
   especificador de formata√ß√£o escrevendo o tamanho do nosso array ap√≥s o `%`.

   @code c
   #include <stdio.h>

   int main(void) {
      char name[5];

      if (scanf("%4s", name) != 1)
         return 1;

      printf("Hello %s\n", name);
      return 0;
   }
   @end

   O tamanho t√™m de ser um menos do que o tamanho do array, pois o byte nulo √©
   acrescentado a este.

   @code
   ./compile code/ex03-scanf-v2.c && ./main
   antonio
   Hello anto
   @end

   Mais uma vez o resultado √© truncado para caber no nosso array, prevenindo
   escrever depois da mem√≥ria alocada.

   S√≥ resta um problema a resolver, o especificador `%s` l√™ at√© encontrar um
   "espa√ßo", a linha nova conta como um "espa√ßo", mas um espa√ßo normal tamb√©m
   conta, o que nos previne de inserir espa√ßos na nossa string.

   @code
   ./compile code/ex03-scanf-v2.c && ./main
   l l
   Hello l
   @end

   Para resolver isto temos de utilizar outro especificador, neste caso vamos
   definir que caracteres queremos aceitar utilizando o especificador `%[` que
   aceita uma lista de caracteres a ler e, se utilizarmos o `^`, a lista de
   caracteres a n√£o ler, no nosso caso vamos utilizar `%[^\n]` para ler todos
   os caracteres menos a linha nova.

   @code c
   #include <stdio.h>

   int main(void) {
      char name[5];

      if (scanf("%4[^\n]", name) != 1)
         return 1;

      printf("Hello %s\n", name);
      return 0;
   }
   @end

   @code
   ./compile code/ex03-scanf-v3.c && ./main
   l l
   Hello l l
   @end

** Programa final

   J√° vimos tr√™s maneiras de como podemos escrever o programa, uma delas n√£o
   vamos usar de certeza. Eu vou utilizar `scanf` para escrever o programa
   final.

   @code c
   #include <stdio.h>

   int main(void) {
      char nome[20];
      char apelido[20];

      printf("Nome: ");
      if (scanf("%19[^\n]", nome) != 1)
         return 1;

      // Discard newlines from stdin so that the next `scanf`
      // doesn't return immediately.
      while (1) {
         char c = getchar();

         if (c == '\n' || c == EOF)
            break;
      }

      printf("Apelido: ");
      if (scanf("%19[^\n]", apelido) != 1)
         return 1;

      printf("Hello %s %s!\n", nome, apelido);
      return 0;
   }
   @end

   Tivemos de limpar linhas novas do stdin entre as duas chamadas a `scanf`,
   para que a segunda n√£o retornasse instantaneamente.

   @code 
   ./compile code/ex03.c && ./main
   Nome: Jo√£o
   Apelido: Capucho
   Hello Jo√£o Capucho!
   @end

* Exerc√≠cio 4

  > Desenvolva um programa que escreva uma tabela com os quadrados e as ra√≠zes
    quadradas dos primeiros n√∫meros naturais. O utilizador deve indicar quantas
    linhas tem a tabela.
  > Formate as colunas da tabela de modo apropriado; as colunas da tabela
    dever√£o ter um cabe√ßalho.
  > O que √© necess√°rio fazer para poder usar a fun√ß√£o sqrt()?

** `sqrt`

   A fun√ß√£o `sqrt` √© definida no header `math.h`, vamos tentar utiliz√°-la, na
   p√°gina de manual, diz tamb√©m que √© necess√°rio utilizar `-lm` para a linkar no
   nosso programa.

   Vamos ent√£o definir um simples programa de teste para testar a `sqrt`:

   @code c
   #include <math.h>
   #include <stdio.h>

   int main(void) {
      float result = sqrt(4.0);
      printf("%f\n", result);
      return 0;
   }
   @end

   @code
   $ ./compile code/ex04-sqrt-no-link.c && ./main
   2.000000
   @end

   O c√≥digo funciona como esper√°vamos... Com a exce√ß√£o de que n√£o utilizamos a
   op√ß√£o `-lm` que era necess√°ria. Ser√° que afinal est√° n√£o √© necess√°ria? Vamos
   tentar um programa mais complexo:

   @code c
   #include <math.h>
   #include <stdio.h>

   int main(void) {
      float a;

      if (scanf("%f", &a) != 1)
         return 1;

      float result = sqrt(a);
      printf("%f\n", result);
      return 0;
   }
   @end

   @code
   $ ./compile code/ex04-sqrt-link.c && ./main
   /nix/store/8zxgqm6d879hskwh5g1l4crysl01kdv0-binutils-2.40/bin/ld: /tmp/ccdze44U.o: in function `main':
   /home/capucho/universidade/2ano1/AED/aula01/code/ex04-sqrt-link.c:10: undefined reference to `sqrtf'
   collect2: error: ld returned 1 exit status
   @end

   Desta vez o programa n√£o compilou apesar de estarmos a utilizar bem a
   fun√ß√£o, o linker queixa-se de que n√£o conhece o s√≠mbolo `sqrt`, isto
   acontece porque n√£o dissemos ao linker para utilizar a libraria de `math`
   que cont√™m estes s√≠mbolos, √© isto que a op√ß√£o `-lm` faz, e se a utilizarmos
   o programa compila.

   @code
   $ ./compile -lm code/ex04-sqrt-link.c && ./main
   4
   2.000000
   @end

   Ent√£o por que √© que o primeiro programa funciona? O compilador √© livre de
   otimizar v√°rias partes do programa, e como utilizamos uma constante na
   fun√ß√£o `sqrt` o compilador calculou durante a compila√ß√£o o resultado e
   trocou a chamada a fun√ß√£o pelo resultado, o que faz com que o programa final
   n√£o contenha o s√≠mbolo `sqrt`.

   Isto √© um tema recorrente em C, o compilador faz certas transforma√ß√µes que
   podem esconder, ou pior amplificar, problemas no c√≥digo que depois tornam-se
   dif√≠ceis de diagnosticar. Por isso temos de ter o dobro do cuidado quando
   escrevemos C.

** Fazer a tabela

   Agora que j√° vimos como fazer a raiz quadrada, vamos fazer agora a tabela.

   O seguinte programa gera a tabela que nos √© pedida (com um tamanho fixo de 5
   linhas por agora).

   @code c
   #include <math.h>
   #include <stdio.h>

   int main(void) {
      int linhas = 5;

      printf("N√∫mero | Quadrado | Raiz\n");

      for (int i = 1; i <= linhas; i++) {
         printf("%d | %d | %f\n", i, i * i, sqrt(i));
      }

      return 0;
   }
   @end

   @code
   $ ./compile -lm code/ex04-table.c && ./main
   N√∫mero | Quadrado | Raiz
   1 | 1 | 1.000000
   2 | 4 | 1.414214
   3 | 9 | 1.732051
   4 | 16 | 2.000000
   5 | 25 | 2.236068
   @end
   
   A tabela, apesar de ter o que queremos, est√° desalinhada, vamos consertar
   isso. Primeiro precisamos de saber quantos caracteres cada coluna precisa.

   O tamanho da coluna precisa de ser suficiente para conter o cabe√ßalho e o
   maior n√∫mero da coluna. Podemos ent√£o calcular o tamanho da coluna como o
   maior desses dois valores.

   Para saber quantos caracteres s√£o precisos para o maior n√∫mero vamos utilizar
   a fun√ß√£o `snprintf`:

   @code c
   int snprintf(char *str, size_t size, const char *format, ...); 
   @end

   Est√° fun√ß√£o tal como `printf` imprime a string formatada, mas inv√©s de ser
   para stdout √© para outra string e o valor de retorno √© o n√∫mero de
   caracteres que foram necess√°rios, logo se passarmos que o tamanho da nossa
   string √© `0` n√£o precisamos de alocar mem√≥ria e conseguimos saber quantos
   caracteres o n√∫mero ocupa.

   @code c
   int width = snprintf(NULL, 0, "%d", 20); // width = 2;
   @end

   Al√©m deste truque para obter o n√∫mero de caracteres necess√°rios para um
   n√∫mero vamos tamb√©m utilizar o especificador `%*` no `printf` para definir
   dinamicamente o tamanho a imprimir.

   Temos ent√£o o seguinte programa que deve imprimir a tabela alinhada:

   @code c
   #include <math.h>
   #include <stdio.h>
   #include <string.h>

   int max(int a, int b) { return a >= b ? a : b; }

   int main(void) {
      int linhas = 5;

      // Cabe√ßalhos
      char *number_header = "N√∫mero";
      char *square_header = "Quadrado";
      char *root_header = "Raiz";

      // Tamanho m√°ximo dos n√∫meros em cada colunas.
      //
      // Todas estas fun√ß√µes s√£o crescentes para n√∫meros naturais,
      // logo basta calcular para o maior n√∫mero.
      int max_number_width = snprintf(NULL, 0, "%d", linhas);
      int max_square_width = snprintf(NULL, 0, "%d", linhas * linhas);
      int max_root_width = snprintf(NULL, 0, "%.5f", sqrt(linhas));

      // Tamanho dos cabe√ßalhos
      int number_header_size = strlen(number_header);
      int square_header_size = strlen(square_header);
      int root_header_size = strlen(root_header);

      // Tamanho das colunas
      int first_column_size = max(max_number_width, number_header_size);
      int second_column_size = max(max_square_width, square_header_size);
      int third_column_size = max(max_root_width, root_header_size);

      // Imprimir o cabe√ßalho
      printf(" %*s | %*s | %*s \n", first_column_size, number_header,
             second_column_size, square_header, third_column_size, root_header);

      // Imprimir as linhas
      for (int i = 1; i <= linhas; i++) {
         printf(" %*d | %*d | %*.5f \n", first_column_size, i, second_column_size,
                i * i, third_column_size, sqrt(i));
      }

      return 0;
   }
   @end

   @code
   $ ./compile -lm code/ex04-table-aligned.c && ./main
    N√∫mero | Quadrado |    Raiz
          1 |        1 | 1.00000
          2 |        4 | 1.41421
          3 |        9 | 1.73205
          4 |       16 | 2.00000
          5 |       25 | 2.23607
   @end

   A tabela continua desalinhada por 1, mas o nosso c√≥digo est√° correto, por
   que est√° a tabela desalinhada? O problema √© o cabe√ßalho `N√∫mero`, este tem
   tamanho *7*...???

   C foi criado num tempo em que a maioria dos computadores eram usados
   exclusivamente em ingl√™s, como tal todas as strings podiam ser tratadas
   como um array de bytes porque ASCII s√≥ precisava de um byte por car√°ter.

   No entanto, todos os alfabetos existentes n√£o cabem num byte, como tal hoje
   em dia usa-se UTF-8 para representar strings, neste a maioria dos caracteres
   utilizados de maneira comum continuam a ser um byte, exceto que alguns
   caracteres como o `√∫` precisam de mais bytes, neste caso 2.

   Mas em C strings continuam a ser arrays de bytes, por isso quando chamamos
   `strlen` ele conta o n√∫mero de bytes, que retorna 7, pois de facto h√° 7
   bytes no array.

   N√£o existe uma maneira simples e correta de consertar isto, por isso o mais
   f√°cil para n√≥s √© s√≥ remover o acento para consertar isto.

** Programa final

   Agora s√≥ falta pedir ao utilizador o n√∫mero de linhas:

   @code c
   #include <math.h>
   #include <stdio.h>
   #include <string.h>

   int max(int a, int b) { return a >= b ? a : b; }

   int main(void) {
      int linhas;

      printf("Numero de linhas: ");
      if (scanf("%d", &linhas) != 1)
         return 1;

      // Cabe√ßalhos
      char *number_header = "Numero";
      char *square_header = "Quadrado";
      char *root_header = "Raiz";

      // Tamanho m√°ximo dos n√∫meros em cada colunas.
      //
      // Todas estas fun√ß√µes s√£o crescentes para n√∫meros naturais,
      // logo basta calcular para o maior n√∫mero.
      int max_number_width = snprintf(NULL, 0, "%d", linhas);
      int max_square_width = snprintf(NULL, 0, "%d", linhas * linhas);
      int max_root_width = snprintf(NULL, 0, "%.5f", sqrt(linhas));

      // Tamanho dos cabe√ßalhos
      int number_header_size = strlen(number_header);
      int square_header_size = strlen(square_header);
      int root_header_size = strlen(root_header);

      // Tamanho das colunas
      int first_column_size = max(max_number_width, number_header_size);
      int second_column_size = max(max_square_width, square_header_size);
      int third_column_size = max(max_root_width, root_header_size);

      // Imprimir o cabe√ßalho
      printf(" %*s | %*s | %*s \n", first_column_size, number_header,
             second_column_size, square_header, third_column_size, root_header);

      // Imprimir as linhas
      for (int i = 1; i <= linhas; i++) {
         printf(" %*d | %*d | %*.5f \n", first_column_size, i, second_column_size,
                i * i, third_column_size, sqrt(i));
      }

      return 0;
   }
   @end

   @code
   $ ./compile -lm code/ex04.c && ./main
   Numero de linhas: 7 
    Numero | Quadrado |    Raiz 
         1 |        1 | 1.00000 
         2 |        4 | 1.41421 
         3 |        9 | 1.73205 
         4 |       16 | 2.00000 
         5 |       25 | 2.23607 
         6 |       36 | 2.44949 
         7 |       49 | 2.64575
   @end

* Exerc√≠cio 5

  > Modifique o programa anterior para que escreva uma tabela com sucessivos
    valores do seno e do cosseno. O utilizador deve indicar o menor valor e o
    maior valor do √¢ngulo (em graus), e o espa√ßamento entre sucessivos valores
    interm√©dios. Por exemplo:

  @code
  ang sin(ang)      cos(ang)
  --- ------------- -------------
   0   0.0000000000  1.0000000000
   5   0.0871557427  0.9961946981
  10   0.1736481777  0.9848077530
  15   0.2588190451  0.9659258263
  20   0.3420201433  0.9396926208
  @end

  @code c
  #include <math.h>
  #include <stdio.h>
  #include <string.h>

  #define M_PI 3.14159265358979323846

  int max(int a, int b) { return a >= b ? a : b; }

  int main(void) {
     int angle_precision = 2;
     int precision = 8;

     float start_angle;
     float end_angle;
     float step_angle;

     printf("Angulo inicial: ");
     if (scanf("%f", &start_angle) != 1)
        return 1;

     printf("Angulo final: ");
     if (scanf("%f", &end_angle) != 1)
        return 1;

     printf("Passo: ");
     if (scanf("%f", &step_angle) != 1)
        return 1;

     // Cabe√ßalhos
     char *angle_header = "ang";
     char *sin_header = "sin (ang)";
     char *cos_header = "cos (ang)";

     // Tamanho m√°ximo dos n√∫meros nas colunas.
     int start_angle_width =
        snprintf(NULL, 0, "%.*f", angle_precision, fabs(start_angle));
     int end_angle_width =
        snprintf(NULL, 0, "%.*f", angle_precision, fabs(end_angle));
     // Mais 1 para o sinal
     int angle_width = max(start_angle_width, end_angle_width) + 1;
     // 3 caracteres para a parte inteira e o ponto e o sinal
     int trig_res_width = 3 + precision;

     // Tamanho das colunas
     int first_column_size = max(angle_width, strlen(angle_header));
     int second_column_size = max(trig_res_width, strlen(sin_header));
     int third_column_size = max(trig_res_width, strlen(cos_header));

     // Imprimir o cabe√ßalho
     printf("%-*s %-*s %-*s\n", first_column_size, angle_header,
            second_column_size, sin_header, third_column_size, cos_header);

     float current_angle = start_angle;

     // Imprimir o separador
     for (int i = 0; i < first_column_size; i++)
        putchar('-');

     putchar(' ');

     for (int i = 0; i < second_column_size; i++)
        putchar('-');

     putchar(' ');

     for (int i = 0; i < third_column_size; i++)
        putchar('-');

     putchar('\n');

     // Imprimir as linhas
     while (1) {
        float angle_radians = current_angle * M_PI / 180;

        printf("%*.*f %*.*f %*.*f\n",
               /* Angle */
               first_column_size, angle_precision, current_angle,
               /* Sine */
               second_column_size, precision, sin(angle_radians),
               /* Cossine */
               third_column_size, precision, cos(angle_radians));

        current_angle += step_angle;

        if (current_angle > end_angle)
           break;
     }

     return 0;
  }
  @end

  @code
  $ ./compile -lm code/ex05-v1.c  && ./main
  Angulo inicial: 20
  Angulo final: 60
  Passo: 5
  ang    sin (ang)   cos (ang)  
  ------ ----------- -----------
   20.00  0.34202013  0.93969262
   25.00  0.42261826  0.90630779
   30.00  0.50000001  0.86602540
   35.00  0.57357643  0.81915205
   40.00  0.64278759  0.76604446
   45.00  0.70710680  0.70710677
   50.00  0.76604445  0.64278761
   55.00  0.81915204  0.57357645
   60.00  0.86602542  0.49999997
  @end

  > Use um menor n√∫mero de casas decimais em cada coluna.

  Basta alterar o `angle_precision` e `precision` no in√≠cio da fun√ß√£o, por
  exemplo:

  @code c
  /* -- SNIP -- */
  int angle_precision = 1;
  int precision = 4;
  /* -- SNIP -- */
  @end

  @code
  $ ./compile -lm code/ex05-v2.c  && ./main
  Angulo inicial: 20
  Angulo final: 40
  Passo: 5
  ang   sin (ang) cos (ang)
  ----- --------- ---------
   20.0    0.3420    0.9397
   25.0    0.4226    0.9063
   30.0    0.5000    0.8660
   35.0    0.5736    0.8192
   40.0    0.6428    0.7660
  @end

  > Modifique o programa para que a tabela seja escrita num ficheiro.

  A seguinte vers√£o modificada imprime o resultado para o stdout, mas se um
  segundo argumento for passado, este √© interpretado como o ficheiro para onde
  escrever a tabela.

  @code c
  #include <math.h>
  #include <stdio.h>
  #include <string.h>

  #define M_PI 3.14159265358979323846

  int max(int a, int b) { return a >= b ? a : b; }

  int main(int argc, char **argv) {
     int angle_precision = 2;
     int precision = 8;

     FILE *output = stdout;

     // O segundo argumento √© interpretado como um o caminho
     // do ficheiro para onde escrever.
     if (argc > 1) {
        output = fopen(argv[1], "w");

        if (output == NULL) {
           perror("Error opening file");
           return 1;
        }
     }

     float start_angle;
     float end_angle;
     float step_angle;

     printf("Angulo inicial: ");
     if (scanf("%f", &start_angle) != 1)
        return 1;

     printf("Angulo final: ");
     if (scanf("%f", &end_angle) != 1)
        return 1;

     printf("Passo: ");
     if (scanf("%f", &step_angle) != 1)
        return 1;

     // Cabe√ßalhos
     char *angle_header = "ang";
     char *sin_header = "sin (ang)";
     char *cos_header = "cos (ang)";

     // Tamanho m√°ximo dos n√∫meros nas colunas.
     int start_angle_width =
        snprintf(NULL, 0, "%.*f", angle_precision, fabs(start_angle));
     int end_angle_width =
        snprintf(NULL, 0, "%.*f", angle_precision, fabs(end_angle));
     // Mais 1 para o sinal
     int angle_width = max(start_angle_width, end_angle_width) + 1;
     // 3 caracteres para a parte inteira e o ponto e o sinal
     int trig_res_width = 3 + precision;

     // Tamanho das colunas
     int first_column_size = max(angle_width, strlen(angle_header));
     int second_column_size = max(trig_res_width, strlen(sin_header));
     int third_column_size = max(trig_res_width, strlen(cos_header));

     // Imprimir o cabe√ßalho
     fprintf(output, "%-*s %-*s %-*s\n", first_column_size, angle_header,
             second_column_size, sin_header, third_column_size, cos_header);

     float current_angle = start_angle;

     // Imprimir o separador
     for (int i = 0; i < first_column_size; i++)
        fputc('-', output);

     fputc(' ', output);

     for (int i = 0; i < second_column_size; i++)
        fputc('-', output);

     fputc(' ', output);

     for (int i = 0; i < third_column_size; i++)
        fputc('-', output);

     fputc('\n', output);

     // Imprimir as linhas
     while (1) {
        float angle_radians = current_angle * M_PI / 180;

        fprintf(output, "%*.*f %*.*f %*.*f\n",
                /* Angle */
                first_column_size, angle_precision, current_angle,
                /* Sine */
                second_column_size, precision, sin(angle_radians),
                /* Cossine */
                third_column_size, precision, cos(angle_radians));

        current_angle += step_angle;

        if (current_angle > end_angle)
           break;
     }

     if (output != stdout) {
        if (fclose(output)) {
           perror("Error closing file");
           return 1;
        }
     }

     return 0;
  }
  @end

  @code
  $ ./compile -lm code/ex05-v3.c  && ./main table
  Angulo inicial: 20
  Angulo final: 60
  Passo: 5
  $ cat table
  ang    sin (ang)   cos (ang)  
  ------ ----------- -----------
   20.00  0.34202013  0.93969262
   25.00  0.42261826  0.90630779
   30.00  0.50000001  0.86602540
   35.00  0.57357643  0.81915205
   40.00  0.64278759  0.76604446
   45.00  0.70710680  0.70710677
   50.00  0.76604445  0.64278761
   55.00  0.81915204  0.57357645
   60.00  0.86602542  0.49999997
  @end

  A fun√ß√£o `fopen` √© usada para criar e abrir em modo de escrita (`"w"`) o
  ficheiro para onde se vai escrever a tabela, ap√≥s acabarmos de escrever tudo
  para o ficheiro √© necess√°rio fech√°-lo com `fclose`, isto garante que todos os
  dados, que podem estar em mem√≥ria tempor√°ria, s√£o mandados para o sistema
  operativo onde este depois escrever√° para o ficheiro.

  Os ficheiros abertos ocupam mem√≥ria e recursos, por isso em programas maiores
  se estes n√£o forem fechados podem causar a exaust√£o destes recursos e causar
  erros ou que o sistema operativo termine o programa.

* Exerc√≠cio 6

  > Desenvolva um programa que liste o n√∫mero de bytes usados para representar
    os tipos primitivos da linguagem C, usando a fun√ß√£o sizeof().


  @code c
  #include <stdio.h>

  int main(void) {
     printf("sizeof(void *) ...... %ld\n", sizeof(void *));
     printf("sizeof(void) ........ %ld\n", sizeof(void));
     printf("sizeof(char) ........ %ld\n", sizeof(char));
     printf("sizeof(short) ....... %ld\n", sizeof(short));
     printf("sizeof(int) ......... %ld\n", sizeof(int));
     printf("sizeof(long) ........ %ld\n", sizeof(long));
     printf("sizeof(long long) ... %ld\n", sizeof(long long));
     printf("sizeof(float) ....... %ld\n", sizeof(float));
     printf("sizeof(double) ...... %ld\n", sizeof(double));
     return 0;
  }
  @end

  @code
  ./compile -lm code/ex06.c   && ./main 
  code/ex06.c: In function ‚Äòmain‚Äô:
  code/ex06.c:5:46: error: invalid application of ‚Äòsizeof‚Äô to a void type [-Werror=pointer-arith]
    5 |   printf("sizeof(void) ........ %ld", sizeof(void));
      |                                              ^~~~
  cc1: all warnings being treated as errors
  @end

  O tamanho do `void` √© como a divis√£o de 0 por 0, `void` representa o tipo
  vazio, a inexist√™ncia de algo, como tal, n√£o t√™m um tamanho ou qualquer outra
  propriedade no standard C, mas o `gcc` define uma extens√£o que define o
  tamanho de `void` como sendo 1. Para a ativarmos basta desativarmos o
  `-Wpedantic`.

  @code
  $ gcc -Wall -Wextra code/ex06.c -o main && ./main
  sizeof(void *) ...... 8
  sizeof(void) ........ 1
  sizeof(char) ........ 1
  sizeof(short) ....... 2
  sizeof(int) ......... 4
  sizeof(long) ........ 8
  sizeof(long long) ... 8
  sizeof(float) ....... 4
  @end

* Exerc√≠cio 7

  > Considere o programa em Java listado de seguida, que apresenta um simples
    exemplo de utiliza√ß√£o de arrays.

  @code java
  /*
  Crie um programa em C equivalente a este em Java.
  */
  public class ProgA {
     public static void main(String[] args) {
        int[] a = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        printArray("a", a);

        int[] b = new int[12];
        cumSum(a, b);
        printArray("b", b);
     }

     public static void printArray(String s, int[] a) {
        System.out.println(s + ":");
        for (int i = 0; i < a.length; i++) {
           System.out.print(a[i] + " ");
        }
        System.out.println();
     }

     public static void cumSum(int[] a, int[] b) {
        int c = 0;
        for (int i = 0; i < a.length; i++) {
           c += a[i];
           b[i] = c;
        }
     }
  }
  @end

  > Usando a linguagem C, desenvolva um programa equivalente com o mesmo tipo de fun√ß√µes.

  @code c
  #include <stddef.h>
  #include <stdio.h>

  void printArray(char *s, int *a, size_t a_length) {
     printf("%s:\n", s);

     for (size_t i = 0; i < a_length; i++)
        printf("%d ", a[i]);

     printf("\n");
  }

  void cumSum(int *a, size_t a_length, int *b) {
     int c = 0;

     for (size_t i = 0; i < a_length; i++) {
        c += a[i];
        b[i] = c;
     }
  }

  int main(void) {
     int a[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
     printArray("a", a, sizeof(a) / sizeof(int));

     int b[12];
     cumSum(a, sizeof(a) / sizeof(int), b);
     printArray("b", b, sizeof(b) / sizeof(int));

     return 0;
  }
  @end

  @code
  $ ./compile -lm code/ex07.c   && ./main
  a:
  31 28 31 30 31 30 31 31 30 31 30 31 
  b:
  31 59 90 120 151 181 212 243 273 304 334 365 
  @end
